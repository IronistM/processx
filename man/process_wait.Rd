% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process.R
\name{process_wait}
\alias{process_wait}
\alias{process_is_alive}
\alias{process_get_exit_status}
\alias{process_signal}
\alias{process_kill}
\title{Process status (and related functions).}
\usage{
process_wait(self, private)

process_is_alive(self, private)

process_get_exit_status(self, private)

process_signal(self, private, signal)

process_kill(self, private, grace)
}
\arguments{
\item{self}{this}

\item{private}{private this}
}
\description{
Process status (and related functions).
}
\section{UNIX}{


The main complication here, is that checking the status of the process
might mean that we need to collect its exit status.

Collecting the exit status always means freeing memory allocated for
the handle.
\itemize{
\item \code{process_wait}:
\enumerate{
\item If we already have its exit status, return immediately.
\item Otherwise, do a blocking \code{waitpid()}.
\item When it's done, collect the exit status.
}
\item \code{process_is_alive}:
\enumerate{
\item If we already have its exit status, then return \code{FALSE}.
\item Otherwise, do a non-blocking \code{waitpid()}.
\item If the \code{waitpid()} says that it is running, then return \code{TRUE}.
\item Otherwise collect its exit status, and return \code{FALSE}.
}
\item \code{process_get_exit_status}:
\enumerate{
\item If we already have the exit status, then return that.
\item Otherwise do a non-blocking \code{waitpid()}.
\item If the process just finished, then collect the exit status, and
also return it.
\item Otherwise return \code{NULL}, the process is still running.
}
\item \code{process_signal}:
\enumerate{
\item If we already have its exit status, return with \code{FALSE}.
\item Otherwise just try to deliver the signal. If successful, return
\code{TRUE}, otherwise return \code{FALSE}.
}

We might as well call \code{waitpid()} as well, but \code{process_signal} is
able to deliver arbitrary signals, so the process might not have
finished.
\item \code{process_kill}:
\enumerate{
\item Check if we have the exit status. If yes, then the process
has already finished. and we return \code{FALSE}. We don't error,
because then there would be no way to deliver a signal.
(Simply doing \code{if (p$is_alive()) p$kill()} does not work, because
it is a race condition.
\item If there is no exit status, the process might be running (or might
be a zombie).
\item We call a non-blocking \code{waitpid()} on the process and potentially
collect the exit status. If the process has exited, then we return
TRUE. This step is to avoid the potential grace period, if the
process is in a zombie state.
\item If the process is still running, we call \code{kill(SIGKILL)}.
\item We do a blocking \code{waitpid()} to collect the exit status.
\item If the process was indeed killed by us, we return \code{TRUE}.
\item Otherwise we return \code{FALSE}.
}

The return value of \code{process_kill()} is \code{TRUE} if the process was
indeed killed by the signal. It is \code{FALSE} otherwise, i.e. if the
process finished.

We currently ignore the grace argument, as there is no way to
implement it on Unix. It will be implemented later using a SIGCHLD
handler.
\item Finalizers:

Finalizers are called on the handle only, so we do not know if the
process has already finished or not.
\enumerate{
\item Call a non-blocking \code{waitpid()} to see if it is still running.
\item If just finished, then collect exit status (=free memory).
\item If it has finished before, then still try to free memory, just in
case the exit status was read out by another package.
\item If it is running, then kill it with SIGKILL, then call a blocking
\code{waitpid()} to clean up the zombie process. Then free all memory.
}

The finalizer is implemented in C, because we might need to use it
from the process startup code (which is C).
}
}

\seealso{
\code{\link[=process_kill]{process_kill()}}
}
\keyword{internal}
