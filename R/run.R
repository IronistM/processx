
#' Run external command, and wait until finishes
#'
#' `run` provides an interface similar to [base::system()] and
#' [base::system2()], but based on the [process] class. This allows some
#' extra features, see below.
#'
#' `run` supports
#' * Specifying a timeout for the command. If the specified time has
#'   passed, and the process is still running, it will be killed
#'   (with all its child processes).
#' * Calling a callback function for each line of the standard output
#'   and/or error.
#'
#' @section Callbacks:
#'
#' Some notes about the callback functions. The first argument of a
#' callback function is a character scalar (length 1 character), a single
#' output or error line. The second argument is always the [process]
#' object. You can manipulate this object, for example you can call
#' `$kill()` on it to terminate it, as a response to a message on the
#' standard output or error.
#'
#' @param command Character scalar, the command to run. It will be
#'   escaped via [base::shQuote].
#' @param args Character vector, arguments to the command. They will be
#'   escaped via [base::shQuote].
#' @param error_on_status Whether to throw an error if the command returns
#'   with a non-zero status, or it is interrupted. The error clases are
#'   `system_command_status_error` and `system_command_timeout_error`,
#'   respectively, and both errors have class `system_command_error` as
#'   well.
#' @param commandline A character scalar, a full command line.
#'   No escaping will be performed on it.
#' @param echo Whether to print the command, the standard output and error
#'   to the screen. Note that the order of the standard output and error
#'   lines are not necessarily correct, as standard output is typically
#'   buffered.
#' @param spinner Whether to show a reassusing spinner while the process
#'   is running.
#' @param timeout Timeout for the process, in seconds, or as a `difftime`
#'   object. If it is not finished before this, it will be killed.
#' @param stdout_callback `NULL`, or a function to call for every line
#'   of the standard output. See more below.
#' @param stderr_callback `NULL`, or a function to call for every line
#'   of the standard error. See more below.
#' @param windows_verbatim_args Whether to omit the escaping of the
#'   command and the arguments on windows. Ignored on other platforms.
#' @param windows_hide_window Whether to hide the window of the
#'   application on windows. Ignored on other platforms.
#' @return A list with components:
#'   * status The exit status of the process. If this is `NA`, then the
#'     process was killed and had no exit status.
#'   * stdout The standard output of the command, in a character vector.
#'   * stderr The standard error of the command, in a character vector.
#'
#' @export
#' @examples
#' ## Different examples for Unix and Windows
#' \dontrun{
#' if (.Platform$OS.type == "unix") {
#'   run("ls")
#'   system.time(run(commandline = "sleep 10", timeout = 1,
#'     error_on_status = FALSE))
#'   system.time(
#'     run(
#'       commandline = "for i in 1 2 3 4 5; do echo $i; sleep 1; done",
#'       timeout=2, error_on_status = FALSE
#'     )
#'   )
#' } else {
#'   run(commandline = "ping -n 1 127.0.0.1")
#'   run(commandline = "ping -n 6 127.0.0.1", timeout = 1,
#'     error_on_status = FALSE)
#' }
#' }

run <- function(
  command = NULL, args = character(), commandline = NULL,
  error_on_status = TRUE, echo = FALSE, spinner = FALSE, timeout = Inf,
  stdout_callback = NULL, stderr_callback = NULL,
  windows_verbatim_args = FALSE, windows_hide_window = TRUE) {

  assert_that(is_flag(error_on_status))
  assert_that(is_time_interval(timeout))
  assert_that(is_flag(spinner))
  assert_that(is.null(stdout_callback) || is.function(stdout_callback))
  assert_that(is.null(stderr_callback) || is.function(stderr_callback))
  ## The rest is checked by process$new()

  if (!interactive()) spinner <- FALSE

  ## Run the process
  pr <- process$new(
    command, args, commandline, echo_cmd = echo,
    windows_verbatim_args = windows_verbatim_args,
    stdout = "|", stderr = "|"
  )

  ## If echo, then we need to create our own callbacks.
  ## These are merged to user callbacks if there are any.
  if (echo) {
    stdout_callback <- echo_callback(stdout_callback, "stdout")
    stderr_callback <- echo_callback(stderr_callback, "stderr")
  }

  res <- run_manage(pr, timeout, spinner, stdout_callback, stderr_callback)

  if (error_on_status && (is.na(res$status) || res$status > 0)) {
    stop(make_condition(res, call = sys.call()))
  }

  res
}

#' @importFrom crayon red

echo_callback <- function(user_callback, type) {
  force(user_callback)
  force(type)
  function(x, ...) {
    out <- paste0(if (type == "stdout") "- " else "x ", x)
    if (type == "stderr") out <- red(out)
    cat(out, "\n", sep = "")
    if (!is.null(user_callback)) user_callback(x, ...)
  }
}

run_manage <- function(proc, timeout, spinner, stdout_callback,
                       stderr_callback) {

  timeout <- as.difftime(timeout, units = "secs")
  start_time <- proc$get_start_time()

  stdout <- character()
  stderr <- character()

  do_output <- function() {
    had_output <- FALSE

    newout <- proc$read_output_lines()
    if (!is.null(stdout_callback)) {
      lapply(newout, function(x) stdout_callback(x, proc))
    }
    stdout <<- c(stdout, newout)
    had_output <- had_output || length(newout) > 0

    newerr <- proc$read_error_lines()
    if (!is.null(stderr_callback)) {
      lapply(newerr, function(x) stderr_callback(x, proc))
    }
    stderr <<- c(stderr, newerr)
    had_output <- had_output || length(newerr) > 0

    had_output
  }

  spin <- (function() {
    state <- 1L
    phases <- c("-", "\\", "|", "-")
    function() {
      cat("\r", phases[state], "\r", sep = "")
      state <<- (state + 1) %% length(phases) + 1L
    }
  })()

  while (proc$is_alive()) {
    ## Timeout? Maybe finished by now...
    if (!is.null(timeout) && Sys.time() - start_time > timeout) {
      proc$kill()
      break
    }

    ## Otherwise just poll for the remaining time
    if (!is.null(timeout) && timeout < Inf) {
      remains <- timeout - (Sys.time() - start_time)
      remains <- as.integer(as.numeric(remains) * 1000)
      if (spinner) remains <- min(remains, 200)
    } else if (spinner) {
      remains <- 200
    } else {
      remains <- -1L
    }
    polled <- proc$poll_io(remains)

    ## If output/error, then collect it
    if (any(polled == "ready")) do_output()

    if (spinner) spin()
  }

  ## Needed to get the exit status
  proc$wait()

  ## We might still have output
  while (proc$is_incomplete_output() || proc$is_incomplete_error()) {
    do_output()
  }

  if (spinner) cat("\r \r")

  list(
    status = proc$get_exit_status(),
    stdout = stdout,
    stderr = stderr
  )
}

make_condition <- function(result, call) {
  if (is.na(result$status)) {
    structure(
      list(
        message = "System command timeout",
        stderr = result$stderr,
        call = call
      ),
      class = c("system_command_timeout_error", "system_command_error",
        "error", "condition")
    )

  } else {
    structure(
      list(
        message = "System command error",
        stderr = result$stderr,
        call = call
      ),
      class = c("system_command_status_error", "system_command_error",
        "error", "condition")
    )
  }
}
